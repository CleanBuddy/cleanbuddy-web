type Address {
    id: ID!
    user: User!
    userId: ID!

    # Address Fields
    label: String
    street: String!
    building: String
    apartment: String
    floor: Int
    city: String!
    neighborhood: String
    postalCode: String!
    county: String
    country: String!

    # Additional Information
    accessInstructions: String
    isDefault: Boolean!

    # Coordinates (from Google Maps)
    latitude: Float
    longitude: Float

    # Google Maps Place ID (for verification and future lookups)
    googlePlaceId: String

    createdAt: Time!
    updatedAt: Time!
}

input CreateAddressInput {
    # Google Maps Place ID (required - from Google Places API autocomplete)
    googlePlaceId: String!

    # Address fields (populated from Google Maps API)
    street: String!
    city: String!
    postalCode: String!
    county: String
    country: String!
    latitude: Float!
    longitude: Float!

    # User-provided details
    label: String
    building: String
    apartment: String
    floor: Int
    neighborhood: String
    accessInstructions: String
    isDefault: Boolean
}

input UpdateAddressInput {
    id: ID!
    label: String
    street: String
    building: String
    apartment: String
    floor: Int
    city: String
    neighborhood: String
    postalCode: String
    county: String
    country: String
    accessInstructions: String
    isDefault: Boolean
    latitude: Float
    longitude: Float
}

## QUERIES

extend type Query {
    # Get address by ID
    address(id: ID!): Address @authRequired

    # Get all addresses for current user
    myAddresses: [Address!]! @authRequired

    # Get default address for current user
    myDefaultAddress: Address @authRequired
}

## MUTATIONS

extend type Mutation {
    # Create address
    createAddress(input: CreateAddressInput!): Address! @authRequired

    # Update address
    updateAddress(input: UpdateAddressInput!): Address! @authRequired

    # Delete address
    deleteAddress(id: ID!): Void! @authRequired

    # Set address as default
    setDefaultAddress(id: ID!): Address! @authRequired
}
enum ApplicationType {
    CLEANER
    COMPANY_ADMIN
}

enum ApplicationStatus {
    PENDING
    APPROVED
    REJECTED
}

input CompanyInfoInput {
    companyName: String!
    registrationNumber: String!
    taxId: String!
    companyStreet: String!
    companyCity: String!
    companyPostalCode: String!
    companyCounty: String
    companyCountry: String!
    businessType: String
}

input ApplicationDocumentsInput {
    identityDocument: Upload!
    businessRegistration: Upload
    insuranceCertificate: Upload
    additionalDocuments: [Upload!]
}

input SubmitApplicationInput {
    applicationType: ApplicationType!
    message: String
    companyInfo: CompanyInfoInput
    documents: ApplicationDocumentsInput
}

type CompanyInfo {
    companyName: String!
    registrationNumber: String!
    taxId: String!
    companyStreet: String!
    companyCity: String!
    companyPostalCode: String!
    companyCounty: String
    companyCountry: String!
    businessType: String
}

type ApplicationDocuments {
    identityDocumentUrl: String!
    businessRegistrationUrl: String
    insuranceCertificateUrl: String
    additionalDocuments: [String!]
}

type Application {
    id: ID!
    user: User! @goField(forceResolver: true)
    applicationType: ApplicationType!
    status: ApplicationStatus!
    message: String
    companyInfo: CompanyInfo
    documents: ApplicationDocuments
    rejectionReason: String
    reviewedBy: User @goField(forceResolver: true)
    reviewedAt: Time
    createdAt: Time!
    updatedAt: Time!
}

## QUERIES

extend type Query {
    application(id: ID!): Application @authRequired
    myApplications: [Application!]! @authRequired
    pendingApplications: [Application!]! @authRequired
    generateDocumentSignedUrl(documentUrl: String!): String! @authRequired
}

## MUTATIONS

extend type Mutation {
    submitApplication(input: SubmitApplicationInput!): Application! @authRequired
    approveApplication(applicationId: ID!): Application! @authRequired
    rejectApplication(applicationId: ID!, reason: String): Application! @authRequired
}

type AuthResult {
    accessToken: String!
    refreshToken: String!
}

enum AuthIdentityKind {
    GoogleOAuth2
}


## MUTATIONS

extend type Mutation {
    # Used for both the initial sign-up and subsequent sing-ins, when the client has no information about the user session
    # This flow will trigger the OAuth workflow, where the client will hand off the request to the appropriate social provider
    # in order to obtain the authorization code
    authWithIdentityProvider(code: String!, kind: AuthIdentityKind!, intent: String): AuthResult!
    # Used for when an existing user session is already associated with the client
    authWithRefreshToken(token: String!): AuthResult!
}
enum AvailabilityType {
    AVAILABLE
    UNAVAILABLE
}

enum RecurrencePattern {
    NONE
    WEEKLY
}

type Availability {
    id: ID!
    cleanerProfile: CleanerProfile!
    cleanerProfileId: ID!

    # Type
    type: AvailabilityType!

    # Date and Time
    date: Time!
    startTime: String!
    endTime: String!

    # Recurrence
    isRecurring: Boolean!
    recurrencePattern: RecurrencePattern
    recurrenceEnd: Time

    # Notes
    notes: String

    createdAt: Time!
    updatedAt: Time!
}

input CreateAvailabilityInput {
    type: AvailabilityType!
    date: Time!
    startTime: String!
    endTime: String!
    isRecurring: Boolean
    recurrencePattern: RecurrencePattern
    recurrenceEnd: Time
    notes: String
}

input UpdateAvailabilityInput {
    id: ID!
    type: AvailabilityType
    date: Time
    startTime: String
    endTime: String
    isRecurring: Boolean
    recurrencePattern: RecurrencePattern
    recurrenceEnd: Time
    notes: String
}

input AvailabilityFiltersInput {
    type: AvailabilityType
    startDate: Time
    endDate: Time
}

input CheckAvailabilityInput {
    cleanerProfileId: ID!
    date: Time!
    startTime: String!
    endTime: String!
}

## QUERIES

extend type Query {
    # Get availability by ID
    availability(id: ID!): Availability @authRequired

    # Get availability for a cleaner profile
    availabilityForCleaner(
        cleanerProfileId: ID!
        filters: AvailabilityFiltersInput
        limit: Int
        offset: Int
    ): [Availability!]! @authRequired

    # Get my availability (for current cleaner)
    myAvailability(
        filters: AvailabilityFiltersInput
        limit: Int
        offset: Int
    ): [Availability!]! @authRequired

    # Check if cleaner is available at specific date/time
    isCleanerAvailable(input: CheckAvailabilityInput!): Boolean! @authRequired
}

## MUTATIONS

extend type Mutation {
    # Create availability entry
    createAvailability(input: CreateAvailabilityInput!): Availability! @authRequired

    # Update availability entry
    updateAvailability(input: UpdateAvailabilityInput!): Availability! @authRequired

    # Delete availability entry
    deleteAvailability(id: ID!): Void! @authRequired

    # Bulk create availability (e.g., set weekly schedule)
    bulkCreateAvailability(inputs: [CreateAvailabilityInput!]!): [Availability!]! @authRequired
}
enum BookingStatus {
    PENDING
    CONFIRMED
    IN_PROGRESS
    COMPLETED
    CANCELLED
    NO_SHOW
}

enum CancellationReason {
    CUSTOMER_REQUEST
    CLEANER_REQUEST
    EMERGENCY
    WEATHER
    OTHER
}

type Booking {
    id: ID!
    customer: User!
    customerId: ID!
    cleaner: User!
    cleanerId: ID!
    cleanerProfile: CleanerProfile!
    cleanerProfileId: ID!

    # Service Details
    serviceType: ServiceType!
    serviceFrequency: ServiceFrequency!
    serviceAddOns: [ServiceAddOn!]!

    # Scheduling
    scheduledDate: Time!
    scheduledTime: String!
    duration: Float!

    # Address
    address: Address!
    addressId: ID!

    # Pricing (in bani)
    cleanerHourlyRate: Int!
    servicePrice: Int!
    addOnsPrice: Int!
    travelFee: Int!
    platformFee: Int!
    totalPrice: Int!
    cleanerPayout: Int!

    # Status and Progress
    status: BookingStatus!
    cancellationReason: CancellationReason
    cancellationNote: String
    cancelledBy: User
    cancelledById: ID
    cancelledAt: Time

    # Timestamps
    confirmedAt: Time
    startedAt: Time
    completedAt: Time

    # Recurring Booking Support
    isRecurring: Boolean!
    parentBookingId: ID
    nextBookingId: ID

    # Special Instructions
    customerNotes: String
    cleanerNotes: String

    # Related Data
    review: Review @goField(forceResolver: true)
    transaction: Transaction @goField(forceResolver: true)

    createdAt: Time!
    updatedAt: Time!
}

type BookingEdge {
    node: Booking!
    cursor: ID!
}

type BookingConnection {
    edges: [BookingEdge!]!
    totalCount: Int!
}

input CreateBookingAddressInput {
  street: String!
  city: String!
  postalCode: String!
  country: String!
  latitude: Float!
  longitude: Float!
  county: String
  googlePlaceId: String
}

input CreateBookingUserInput {
  displayName: String!
  email: String!
}

input CreateBookingInput {
    cleanerProfileId: ID!
    addressId: ID
    address: CreateBookingAddressInput
    serviceType: ServiceType!
    serviceFrequency: ServiceFrequency!
    serviceAddOns: [ServiceAddOn!]
    scheduledDate: Time!
    scheduledTime: String!
    customerNotes: String
    isRecurring: Boolean
    user: CreateBookingUserInput
}

input UpdateBookingInput {
    id: ID!
    scheduledDate: Time
    scheduledTime: String
    customerNotes: String
    cleanerNotes: String
}

input CancelBookingInput {
    id: ID!
    reason: CancellationReason!
    note: String
}

input BookingFiltersInput {
    status: BookingStatus
    serviceType: ServiceType
    startDate: Time
    endDate: Time
    minPrice: Int
    maxPrice: Int
    isRecurring: Boolean
}

## QUERIES

extend type Query {
    # Get booking by ID
    booking(id: ID!): Booking @authRequired

    # Get my bookings (as customer)
    myBookings(
        filters: BookingFiltersInput
        limit: Int
        offset: Int
        orderBy: String
    ): BookingConnection! @authRequired

    # Get my jobs (as cleaner)
    myJobs(
        filters: BookingFiltersInput
        limit: Int
        offset: Int
        orderBy: String
    ): BookingConnection! @authRequired

    # Get upcoming bookings (next 7 days by default)
    upcomingBookings(limit: Int): [Booking!]! @authRequired

    # Admin: List all bookings
    allBookings(
        filters: BookingFiltersInput
        limit: Int
        offset: Int
        orderBy: String
    ): BookingConnection! @authRequired
}

## MUTATIONS

extend type Mutation {
    # Create a new booking (supports guest checkout via user input)
    createBooking(input: CreateBookingInput!): Booking!

    # Update booking details
    updateBooking(input: UpdateBookingInput!): Booking! @authRequired

    # Confirm booking (cleaner action)
    confirmBooking(id: ID!): Booking! @authRequired

    # Start booking (cleaner marks as in progress)
    startBooking(id: ID!): Booking! @authRequired

    # Complete booking (cleaner marks as completed)
    completeBooking(id: ID!, cleanerNotes: String): Booking! @authRequired

    # Cancel booking
    cancelBooking(input: CancelBookingInput!): Booking! @authRequired

    # Mark as no-show
    markNoShow(id: ID!): Booking! @authRequired
}
enum CleanerInviteStatus {
    PENDING
    ACCEPTED
    EXPIRED
    REVOKED
}

type CleanerInvite {
    id: ID!
    token: String!
    company: Company! @goField(forceResolver: true)
    createdBy: User! @goField(forceResolver: true)
    email: String
    message: String
    status: CleanerInviteStatus!
    acceptedBy: User @goField(forceResolver: true)
    acceptedAt: Time
    expiresAt: Time!
    createdAt: Time!
}

type CleanerInviteResult {
    invite: CleanerInvite!
    inviteUrl: String!
}

type ValidateCleanerInviteResult {
    valid: Boolean!
    invite: CleanerInvite
    company: Company
    errorMessage: String
}

type AcceptCleanerInviteResult {
    success: Boolean!
    user: User!
    company: Company!
}

input CreateCleanerInviteInput {
    email: String
    message: String
    expiresInDays: Int
}

## QUERIES

extend type Query {
    # Validate an invite token (public - no auth required)
    validateCleanerInviteToken(token: String!): ValidateCleanerInviteResult!

    # Get a specific invite by ID (company admin only)
    cleanerInvite(id: ID!): CleanerInvite @authRequired

    # List all invites for current user's company (company admin only)
    myCompanyInvites: [CleanerInvite!]! @authRequired

    # List all cleaners for current user's company (company admin only)
    myCompanyCleaners: [CleanerProfile!]! @authRequired
}

## MUTATIONS

extend type Mutation {
    # Create a new cleaner invite (company admin only)
    createCleanerInvite(input: CreateCleanerInviteInput): CleanerInviteResult! @authRequired

    # Accept a cleaner invite (authenticated users only)
    acceptCleanerInvite(token: String!): AcceptCleanerInviteResult! @authRequired

    # Revoke an invite (company admin only)
    revokeCleanerInvite(id: ID!): CleanerInvite! @authRequired
}
enum CleanerTier {
    NEW
    STANDARD
    PREMIUM
    PRO
}

type CleanerProfile {
    id: ID!
    user: User! @goField(forceResolver: true)
    userId: ID!
    company: Company @goField(forceResolver: true)
    companyId: ID

    # Profile Information
    bio: String
    profilePicture: String

    # Tier and Performance
    tier: CleanerTier!
    hourlyRate: Int! # Rate in bani (100 bani = 1 RON)
    totalBookings: Int!
    completedBookings: Int!
    cancelledBookings: Int!
    averageRating: Float!
    totalReviews: Int!
    totalEarnings: Int!

    # Availability
    isActive: Boolean!
    isAvailableToday: Boolean!

    # Verification
    isVerified: Boolean!
    verifiedAt: Time
    backgroundCheck: Boolean!
    identityVerified: Boolean!

    # Related Data
    serviceAreas: [ServiceArea!]! @goField(forceResolver: true)
    reviews: [Review!]! @goField(forceResolver: true)
    availability: [Availability!]! @goField(forceResolver: true)

    createdAt: Time!
    updatedAt: Time!
}

type CleanerProfileEdge {
    node: CleanerProfile!
    cursor: ID!
}

type CleanerProfileConnection {
    edges: [CleanerProfileEdge!]!
    totalCount: Int!
}

type TierRateRange {
    tier: CleanerTier!
    minRate: Int!
    maxRate: Int!
}

input CreateCleanerProfileInput {
    bio: String
    profilePicture: String
    hourlyRate: Int!
    serviceAreaInputs: [CreateServiceAreaInput!]!
}

input UpdateCleanerProfileInput {
    bio: String
    profilePicture: String
    hourlyRate: Int
    isActive: Boolean
    isAvailableToday: Boolean
}

input CleanerProfileFiltersInput {
    tier: CleanerTier
    minRating: Float
    maxRating: Float
    minHourlyRate: Int
    maxHourlyRate: Int
    isActive: Boolean
    isVerified: Boolean
    isAvailableToday: Boolean
    serviceAreaIds: [ID!]
    city: String
    neighborhood: String
    postalCode: String
}

## QUERIES

extend type Query {
    # Get cleaner profile by ID
    cleanerProfile(id: ID!): CleanerProfile @authRequired

    # Get cleaner profile by user ID
    cleanerProfileByUserId(userId: ID!): CleanerProfile @authRequired

    # Get current user's cleaner profile (if they are a cleaner)
    myCleanerProfile: CleanerProfile @authRequired

    # Search and list cleaner profiles
    searchCleaners(
        filters: CleanerProfileFiltersInput
        limit: Int
        offset: Int
        orderBy: String
    ): CleanerProfileConnection! @authRequired

    # Get available cleaners for a specific date/time and location
    availableCleaners(
        date: Time!
        startTime: String!
        duration: Float!
        city: String!
        neighborhood: String
        postalCode: String
        filters: CleanerProfileFiltersInput
    ): [CleanerProfile!]! @authRequired

    # Get tier rate ranges
    tierRateRanges: [TierRateRange!]!
}

## MUTATIONS

extend type Mutation {
    # Create cleaner profile (after application approval)
    createCleanerProfile(input: CreateCleanerProfileInput!): CleanerProfile! @authRequired

    # Update cleaner profile
    updateCleanerProfile(input: UpdateCleanerProfileInput!): CleanerProfile! @authRequired

    # Delete cleaner profile
    deleteCleanerProfile: Void! @authRequired

    # Update cleaner tier (admin only)
    updateCleanerTier(profileId: ID!, tier: CleanerTier!): CleanerProfile! @authRequired
}
enum CompanyType {
    INDIVIDUAL
    BUSINESS
}

type Company {
    id: ID!
    adminUser: User! @goField(forceResolver: true)
    companyType: CompanyType!

    # Company Information
    companyName: String!
    registrationNumber: String!
    taxId: String!
    companyStreet: String!
    companyCity: String!
    companyPostalCode: String!
    companyCounty: String
    companyCountry: String!
    businessType: String

    # Documents
    documents: ApplicationDocuments

    # Status
    isActive: Boolean!

    # Stats
    totalCleaners: Int!
    activeCleaners: Int!

    # Related Data
    cleaners: [CleanerProfile!]! @goField(forceResolver: true)

    createdAt: Time!
    updatedAt: Time!
}

input UpdateCompanyInput {
    companyName: String
    companyStreet: String
    companyCity: String
    companyPostalCode: String
    companyCounty: String
    businessType: String
    isActive: Boolean
}

## QUERIES

extend type Query {
    # Get the current user's company (if they are a company admin)
    myCompany: Company @authRequired

    # Get a company by ID (global admin only)
    company(id: ID!): Company @authRequired

    # List all companies (global admin only)
    companies: [Company!]! @authRequired
}

## MUTATIONS

extend type Mutation {
    # Update the current user's company (company admin only)
    updateCompany(input: UpdateCompanyInput!): Company! @authRequired
}
# Common directives
directive @goField(forceResolver: Boolean, name: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
directive @goExtraField(name: String, type: String!, description: String) on OBJECT | INPUT_OBJECT
directive @authRequired on FIELD_DEFINITION

# Common scalars
scalar Time
scalar Upload
scalar Void
scalar JSON
scalar TimeInterval

# Pagination helpers
input ForwardPaginationInput {
    first: Int
    after: ID
}
enum ReviewStatus {
    PENDING
    APPROVED
    REJECTED
    FLAGGED
}

type Review {
    id: ID!
    booking: Booking!
    bookingId: ID!
    customer: User!
    customerId: ID!
    cleaner: User!
    cleanerId: ID!
    cleanerProfile: CleanerProfile!
    cleanerProfileId: ID!

    # Rating (1-5 stars)
    rating: Int!

    # Review Content
    title: String
    comment: String

    # Detailed Ratings (optional)
    qualityRating: Int
    punctualityRating: Int
    professionalismRating: Int
    valueRating: Int

    # Moderation
    status: ReviewStatus!
    flagReason: String
    moderationNote: String
    moderatedBy: User
    moderatedById: ID
    moderatedAt: Time

    # Response from Cleaner
    cleanerResponse: String
    respondedAt: Time

    # Helpfulness tracking
    helpfulCount: Int!
    notHelpfulCount: Int!

    createdAt: Time!
    updatedAt: Time!
}

type ReviewEdge {
    node: Review!
    cursor: ID!
}

type ReviewConnection {
    edges: [ReviewEdge!]!
    totalCount: Int!
    averageRating: Float!
}

input CreateReviewInput {
    bookingId: ID!
    rating: Int!
    title: String
    comment: String
    qualityRating: Int
    punctualityRating: Int
    professionalismRating: Int
    valueRating: Int
}

input UpdateReviewInput {
    id: ID!
    rating: Int
    title: String
    comment: String
    qualityRating: Int
    punctualityRating: Int
    professionalismRating: Int
    valueRating: Int
}

input AddCleanerResponseInput {
    reviewId: ID!
    response: String!
}

input ModerateReviewInput {
    reviewId: ID!
    status: ReviewStatus!
    note: String
}

input FlagReviewInput {
    reviewId: ID!
    reason: String!
}

input ReviewFiltersInput {
    status: ReviewStatus
    minRating: Int
    maxRating: Int
    hasComment: Boolean
}

## QUERIES

extend type Query {
    # Get review by ID
    review(id: ID!): Review @authRequired

    # Get review by booking ID
    reviewByBooking(bookingId: ID!): Review @authRequired

    # Get reviews for a cleaner profile
    reviewsForCleaner(
        cleanerProfileId: ID!
        filters: ReviewFiltersInput
        limit: Int
        offset: Int
        orderBy: String
    ): ReviewConnection! @authRequired

    # Get reviews written by current user
    myReviews(
        filters: ReviewFiltersInput
        limit: Int
        offset: Int
        orderBy: String
    ): ReviewConnection! @authRequired

    # Admin: Get reviews pending moderation
    reviewsPendingModeration(limit: Int): [Review!]! @authRequired
}

## MUTATIONS

extend type Mutation {
    # Create a review
    createReview(input: CreateReviewInput!): Review! @authRequired

    # Update a review
    updateReview(input: UpdateReviewInput!): Review! @authRequired

    # Delete a review
    deleteReview(id: ID!): Void! @authRequired

    # Cleaner: Add response to review
    addCleanerResponse(input: AddCleanerResponseInput!): Review! @authRequired

    # Flag a review for moderation
    flagReview(input: FlagReviewInput!): Review! @authRequired

    # Admin: Moderate review
    moderateReview(input: ModerateReviewInput!): Review! @authRequired

    # Mark review as helpful/not helpful
    markReviewHelpful(reviewId: ID!, helpful: Boolean!): Review! @authRequired
}
enum ServiceType {
    GENERAL
    DEEP
    MOVE_IN_OUT
}

enum ServiceFrequency {
    ONE_TIME
    WEEKLY
    BI_MONTHLY
    MONTHLY
}

enum ServiceAddOn {
    OVEN
    WINDOWS
    FRIDGE
    GARAGE
}

type ServiceDefinition {
    id: ID!
    type: ServiceType!

    # Service Details
    name: String!
    description: String

    # Duration and Pricing Modifiers
    baseHours: Float!
    priceMultiplier: Float!

    # Availability
    isActive: Boolean!

    createdAt: Time!
    updatedAt: Time!
}

type ServiceAddOnDefinition {
    id: ID!
    addOn: ServiceAddOn!

    # Add-On Details
    name: String!
    description: String

    # Pricing
    fixedPrice: Int!
    estimatedHours: Float!

    # Availability
    isActive: Boolean!

    createdAt: Time!
    updatedAt: Time!
}

type ServicePriceCalculation {
    servicePrice: Int!
    addOnsPrice: Int!
    travelFee: Int!
    platformFee: Int!
    totalPrice: Int!
    cleanerPayout: Int!
    estimatedDuration: Float!
}

input CalculateServicePriceInput {
    cleanerProfileId: ID!
    serviceType: ServiceType!
    addOns: [ServiceAddOn!]
    addressId: ID!
}

input CreateServiceDefinitionInput {
    type: ServiceType!
    name: String!
    description: String
    baseHours: Float!
    priceMultiplier: Float!
}

input UpdateServiceDefinitionInput {
    id: ID!
    name: String
    description: String
    baseHours: Float
    priceMultiplier: Float
    isActive: Boolean
}

input CreateAddOnDefinitionInput {
    addOn: ServiceAddOn!
    name: String!
    description: String
    fixedPrice: Int!
    estimatedHours: Float!
}

input UpdateAddOnDefinitionInput {
    id: ID!
    name: String
    description: String
    fixedPrice: Int
    estimatedHours: Float
    isActive: Boolean
}

## QUERIES

extend type Query {
    # Get service definition by type
    serviceDefinition(type: ServiceType!): ServiceDefinition

    # List all service definitions
    serviceDefinitions(activeOnly: Boolean): [ServiceDefinition!]!

    # Get add-on definition
    addOnDefinition(addOn: ServiceAddOn!): ServiceAddOnDefinition

    # List all add-on definitions
    addOnDefinitions(activeOnly: Boolean): [ServiceAddOnDefinition!]!

    # Calculate service price
    calculateServicePrice(input: CalculateServicePriceInput!): ServicePriceCalculation! @authRequired
}

## MUTATIONS

extend type Mutation {
    # Admin: Create service definition
    createServiceDefinition(input: CreateServiceDefinitionInput!): ServiceDefinition! @authRequired

    # Admin: Update service definition
    updateServiceDefinition(input: UpdateServiceDefinitionInput!): ServiceDefinition! @authRequired

    # Admin: Create add-on definition
    createAddOnDefinition(input: CreateAddOnDefinitionInput!): ServiceAddOnDefinition! @authRequired

    # Admin: Update add-on definition
    updateAddOnDefinition(input: UpdateAddOnDefinitionInput!): ServiceAddOnDefinition! @authRequired
}
type ServiceArea {
    id: ID!
    cleanerProfile: CleanerProfile!
    cleanerProfileId: ID!

    # Location Information
    city: String!
    neighborhood: String!
    postalCode: String!

    # Travel Settings
    travelFee: Int!
    isPreferred: Boolean!

    createdAt: Time!
    updatedAt: Time!
}

input CreateServiceAreaInput {
    city: String!
    neighborhood: String!
    postalCode: String!
    travelFee: Int
    isPreferred: Boolean
}

input UpdateServiceAreaInput {
    id: ID!
    city: String
    neighborhood: String
    postalCode: String
    travelFee: Int
    isPreferred: Boolean
}

## QUERIES

extend type Query {
    # Get service area by ID
    serviceArea(id: ID!): ServiceArea @authRequired

    # Get all service areas for a cleaner profile
    serviceAreasByCleanerProfile(cleanerProfileId: ID!): [ServiceArea!]! @authRequired

    # Get my service areas (for current cleaner)
    myServiceAreas: [ServiceArea!]! @authRequired

    # Find cleaners in a specific area
    cleanersInArea(city: String!, neighborhood: String!): [CleanerProfile!]! @authRequired

    # Find cleaners by postal code
    cleanersByPostalCode(postalCode: String!): [CleanerProfile!]! @authRequired
}

## MUTATIONS

extend type Mutation {
    # Add service area to cleaner profile
    addServiceArea(input: CreateServiceAreaInput!): ServiceArea! @authRequired

    # Update service area
    updateServiceArea(input: UpdateServiceAreaInput!): ServiceArea! @authRequired

    # Delete service area
    deleteServiceArea(id: ID!): Void! @authRequired
}
enum TransactionType {
    PAYMENT
    PAYOUT
    REFUND
}

enum TransactionStatus {
    PENDING
    PROCESSING
    COMPLETED
    FAILED
    CANCELLED
}

enum PaymentMethod {
    CARD
    BANK_TRANSFER
    CASH
}

type Transaction {
    id: ID!
    type: TransactionType!
    status: TransactionStatus!

    # Related Entities
    booking: Booking
    bookingId: ID

    # Payer and Payee
    payer: User!
    payerId: ID!
    payee: User!
    payeeId: ID!

    # Amount Details (in bani)
    amount: Int!
    platformFee: Int!
    netAmount: Int!

    # Payment Details
    paymentMethod: PaymentMethod!
    currency: String!

    # External Payment Provider Data
    stripePaymentId: String
    stripeTransferId: String
    stripeRefundId: String

    # Metadata
    description: String
    metadata: JSON

    # Failure Information
    failureReason: String
    failureCode: String

    # Timestamps
    processedAt: Time!
    completedAt: Time
    failedAt: Time

    createdAt: Time!
    updatedAt: Time!
}

type TransactionEdge {
    node: Transaction!
    cursor: ID!
}

type TransactionConnection {
    edges: [TransactionEdge!]!
    totalCount: Int!
    totalAmount: Int!
}

type PayoutBatch {
    id: ID!
    status: TransactionStatus!

    # Batch Details
    totalAmount: Int!
    totalPayouts: Int!
    periodStart: Time!
    periodEnd: Time!

    # Processing
    initiatedBy: User!
    initiatedById: ID!
    processedAt: Time
    completedAt: Time

    # Metadata
    notes: String

    createdAt: Time!
    updatedAt: Time!
}

type CleanerEarnings {
    cleanerId: ID!
    totalEarnings: Int!
    completedBookings: Int!
    averageEarningsPerBooking: Int!
    pendingPayouts: Int!
}

input TransactionFiltersInput {
    type: TransactionType
    status: TransactionStatus
    paymentMethod: PaymentMethod
    startDate: Time
    endDate: Time
    minAmount: Int
    maxAmount: Int
}

input CreatePayoutBatchInput {
    periodStart: Time!
    periodEnd: Time!
    notes: String
}

## QUERIES

extend type Query {
    # Get transaction by ID
    transaction(id: ID!): Transaction @authRequired

    # Get transaction by Stripe payment ID
    transactionByStripePaymentId(stripePaymentId: String!): Transaction @authRequired

    # Get transactions by booking
    transactionsByBooking(bookingId: ID!): [Transaction!]! @authRequired

    # Get my transactions (as payer or payee)
    myTransactions(
        filters: TransactionFiltersInput
        limit: Int
        offset: Int
        orderBy: String
    ): TransactionConnection! @authRequired

    # Cleaner: Get my earnings
    myEarnings(startDate: Time, endDate: Time): CleanerEarnings! @authRequired

    # Admin: Get all transactions
    allTransactions(
        filters: TransactionFiltersInput
        limit: Int
        offset: Int
        orderBy: String
    ): TransactionConnection! @authRequired

    # Admin: Get transactions due for payout
    transactionsDueForPayout(beforeDate: Time!): [Transaction!]! @authRequired

    # Admin: Get payout batch
    payoutBatch(id: ID!): PayoutBatch @authRequired

    # Admin: List payout batches
    payoutBatches(limit: Int, offset: Int): [PayoutBatch!]! @authRequired
}

## MUTATIONS

extend type Mutation {
    # Admin: Create payout batch
    createPayoutBatch(input: CreatePayoutBatchInput!): PayoutBatch! @authRequired

    # Admin: Process payout batch
    processPayoutBatch(id: ID!): PayoutBatch! @authRequired
}
enum UserRole {
    CLIENT
    PENDING_APPLICATION
    PENDING_CLEANER
    REJECTED_CLEANER
    CLEANER
    PENDING_COMPANY_APPLICATION
    PENDING_COMPANY_ADMIN
    REJECTED_COMPANY_ADMIN
    COMPANY_ADMIN
    GLOBAL_ADMIN
}

input UpdateCurrentUserInput {
    displayName: String
}

type User {
    id: ID!
    displayName: String!
    role: UserRole!
    email: String!

    applications: [Application!]! @authRequired @goField(forceResolver: true)
    pendingCleanerApplication: Application @authRequired @goField(forceResolver: true)
}

type UserEdge {
    node: User!
    cursor: ID!
}

type UserConnection {
    edges: [UserEdge!]!
    totalCount: Int!
}

## QUERIES

extend type Query {
    currentUser: User
}

## MUTATIONS

extend type Mutation {
    signOut: Void! @authRequired
    deleteCurrentUser: Void! @authRequired
    updateCurrentUser(input: UpdateCurrentUserInput!): User! @authRequired
    updateUserRole(role: UserRole!): User! @authRequired
}
